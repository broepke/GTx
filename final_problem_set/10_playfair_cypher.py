# One of the early common methods for encrypting text was the
# Playfair cipher. You can read more about the Playfair cipher
# here: https://en.wikipedia.org/wiki/Playfair_cipher
#
# The Playfair cipher starts with a 5x5 matrix of letters,
# such as this one:
#
# D A V I O
# Y N E R B
# C F G H K
# L M P Q S
# T U W X Z
#
# To fit the 26-letter alphabet into 25 letters, I and J are
# merged into one letter. When decrypting the message, it's
# relatively easy to tell from context whether a letter is
# meant to be an i or a j.
#
# To encrypt a message, we first remove all non-letters and
# convert the entire message to the same case. Then, we break
# the message into pairs. For example, imagine we wanted to
# encrypt the message "PS. Hello, worlds". First, we could
# convert it to PSHELLOWORLDS, and then break it into letter
# pairs: PS HE LL OW OR LD S. If there is an odd number of
# characters, we add X to the end.
#
# Then, for each pair of letters, we locate both letters in
# the cipher square. There are four possible orientations
# for the pair of letters: they could be in different rows
# and columns (the "rectangle" case), they could be in the
# same row but different columns (the "row" case), they could
# be in the same column but different rows (the "column"
# case), or they could be the same letter (the "same" case).
#
# Looking at the message PS HE LL OW OR LD SX:
#
# - PS is the Row case: P and S are in the same row.
# - HE is the Rectangle case: H and E are in different rows
#   and columns of the square.
# - LD is the Column case: L and D are in the same column.
# - LL is the Same case as it's two of the same letter.
#
# For the Same case, we replace the second letter in the pair
# with X, and then proceed as normal. When decrypting, it
# would be easy to see the our result was not intended to be
# PS HELXO WORLDSX, and we would thus assume the X is meant to
# repeat the previous letter, becoming PS HELLO WORLDSX.
#
# What we do for each of the other three cases is different:
#
# - For the Rectangle case, we replace each letter with
#   the letter in the same row, but the other letter's
#   column. For example, we would replace HE with GR:
#   G is in the same row as H but the same column as E,
#   and R is in the same row as E but the same column as
#   H. For another example, CS would become KL: K is in
#   C's row but S's column, and L is in C's column but S's
#   row.
# - For the Row case, we pick the letter to the right of
#   each letter, wrapping around the end of the row if we
#   need to. PS becomes QL: Q is to the right of P, and L
#   is to the right of S if we wrap around the end of the
#   row.
# - For the Column case, we pick the letter below each
#   letter, wrapping around if necessary. LD becomes TY:
#   T is below L and Y is below D.
#
# We would then return the resultant encrypted message.
#
# Decrypting a message is essentially the same process.
# You would use the exact same cipher and process, except
# for the Row and Column cases, you would shift left and up
# instead of right and down.
#
# Write two methods: encrypt and decrypt. encrypt should
# take as input a string, and return an encrypted version
# of it according to the rules above.
#
# To encrypt the string, you would:
#
# - Convert the string to uppercase.
# - Replace all Js with Is.
# - Remove all non-letter characters.
# - Add an X to the end if the length if odd.
# - Break the string into character pairs.
# - Replace the second letter of any same-character
#   pair with X (e.g. LL -> LX).
# - Encrypt it.
#
# decrypt should, in turn, take as input a string and
# return the unencrypted version, just undoing the last
# step. You don't need to worry about Js and Is, duplicate
# letters, or odd numbers of characters in decrypt.
#
# For example:
#
# encrypt("PS. Hello, world") -> "QLGRQTVZIBTYQZ"
# decrypt("QLGRQTVZIBTYQZ") -> "PSHELXOWORLDSX"
#
# HINT: You might find it easier if you implement some
# helper functions, like a find_letter function that
# returns the row and column of a letter in the cipher.
#
# HINT 2: Once you've written encrypt, decrypt should
# be trivial: try to think of how you can modify encrypt
# to serve as decrypt.
#
# To make this easier, we've gone ahead and created the
# cipher as a 2D tuple for you:
CIPHER = (("D", "A", "V", "I", "O"),
          ("Y", "N", "E", "R", "B"),
          ("C", "F", "G", "H", "K"),
          ("L", "M", "P", "Q", "S"),
          ("T", "U", "W", "X", "Z"))


# Add your code here!
def encrypt(e_string):
    punctuation = "!#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~\""

    for char in punctuation:
        e_string = e_string.replace(char, "")

    e_string = e_string.upper()
    e_string = e_string.replace("J", "I")
    e_string = e_string.replace(" ", "")

    if len(e_string) % 2 > 0:
        e_string += "X"

    # replace repeated second letters
    for i in range(len(e_string) - 1):
        if e_string[i] == e_string[i + 1]:
            e_string = e_string[:i + 1] + "X" + e_string[i + 2:]
        i += 1

    return e_string


def decrypt(d_string):
    return d_string


# Below are some lines of code that will test your function.
# You can change the value of the variable(s) to test your
# function with different inputs.
#
# If your function works correctly, this will originally
# print: QLGRQTVZIBTYQZ, then PSHELXOWORLDSX
print(encrypt("PS. Hello, worlds!"))
print(decrypt("QLGRQTVZIBTYQZ"))
